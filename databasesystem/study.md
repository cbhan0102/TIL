[데이터베이스시스템]


기존 전산 시스템, 스마트 기기, 소셜 미디어, IoT 센서 등 사회 트렌드의 변화로 대량의 데이터가 저장 및 활용되고 있어 데이터 관리가 점차 중요해지고 있다.
파일 처리 시스템은 프로그램이 직접 데이터에 접근하여 데이터를 저장 및 사용하는 데이터의 중복성, 데이터의 종속성, 데이터의 무결성 훼손, 그리고 동시 접근 이상의 문제점을 내포한다.
데이터베이스는 파일 처리 시스템과 달리 자기 기술성, 추상화, 다중 뷰, 동시성 제어 등의 기능을 통해 파일 처리 시스템의 문제점을 극복한다.
데이터베이스 시스템은 3단계 구조, 즉 외부 단계, 개념 단계 그리고 내부 단계로 구성된다. 외부 단계는 사용자 뷰를 나타내며, 개념 단계는 데이터베이스의 논리적인 전체 구조를 나타내고, 내부 단계는 데이터가 기억장소에 저장되기 위한 물리적 구조를 정의한다.
각 단계 간의 접속에서 특정 외부 스키마와 개념 스키마 간의 대응 관계를 정의한 외부-개념 사상과, 개념 스키마와 내부 스키마 간의 대응 관계를 정의한 개념-내부 사상에 의해 연관성을 갖는다.
데이터베이스 언어란 데이베이스 사용을 위한 언어 형태의 인터페이스로 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로 구성된다.
DBMS는 전체 시스템을 구성하는 방식에 따라 중앙집중식과 분산 시스템 방식으로 아키텍처를 구성할 수 있다.
데이터베이스 모델링 과정은 사용자 요구사항을 분석하여 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링의 단계로 진행된다.
사용자 요구사항 분석 단계에서는 요구사항을 도출하고 분석하고 기록하는 단계로 진행되며, 요구사항이 모호하거나 정확하지 않을 때는 이전 단계로 회귀하여 요구사항을 교정한다.
데이터 모델링이란 데이터에 대한 요구사항을 정의하고 분석하는 방법으로, 데이터 모델링을 통하여 데이터베이스가 구축되기까지는 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링 과정으로 나뉜다.
ER 모델은 전체적인 데이터베이스의 논리적인 구조를 표현하는 전체 스키마의 명세서를 작성하는데 사용되는 개념적 데이터 모델링 도구로, 실세계의 조직 업무의 의미와 상호작용을 개념적으로 나타내는 데 매우 유용하다.
ER 모델의 기본 요소인 개체는 공통된 속성을 가지며 구별 가능한 실세계의 개체들로 구성된다. 이러한 개체들은 각 개체 집합의 구성원들이 가지는 기술적 특성인 속성들의 집합으로 표현되며, 속성의 유형은 단순 속성, 복합 속성, 단일값 속성, 다중값 속성, 유도 속성, 저장 속성, 널 속성 등으로 구분할 수 있다.
ER 모델의 중요한 제약조건은 사상수, 참가 제약조건, 키 속성으로 나뉘며, 이진 관계에서 사상수 비율은 1：1(일대일), 1：N(일대다), N：1(다대일), M：N(다대다)의 형태가 있다.
참가 제약조건에서는 특정 개체 집합이 관계 집합에 참여할 때 모든 개체가 관계에 참여한다면 전체적 참여, 일부만 참가하면 부분적 참여라고 한다. 또한 구조적 제약조건을 통해 개체가 최소 몇 번, 최대 몇 번 관계에 참여할 수 있는지 정의할 수 있다.
키 속성의 경우 어떤 개체 집합 안의 각각의 개체들을 구별해 주기 위해 선택되는 것으로, 최소한의 속성의 조합으로 만들어지며, 대표적으로 사용될 수 있는 속성 조합을 키라고 한다.
동일한 개체 집합이 서로 다른 역할로 참가하여 생성되는 관계 집합을 재귀적 관계 집합이라고 한다. 이때 관계에 참가하는 개체가 행하는 기능을 개체의 역할(role)이라고 한다.
약한 개체 집합은 1：N 관계 집합을 통해 강한 개체 집합에 연결해야 하며, 약한 개체 집합의 구별자(또는 부분키)는 약한 개체 집합 내의 개체들을 구분하는 속성의 집합이다. 따라서 약한 개체 집합의 키 설정은 반드시 지배 개체 집합의 키와 약한 개체 집합의 부분키로 구성되어야 한다.
관계형 모델은 표와 매우 유사한 구조인 릴레이션에 기초한다. 레코드는 릴레이션의 각 행을 의미하며, 컬럼은 각 열을 의미한다. 이때 릴레이션 스키마란 어떠한 테이블에서 사용되는 컬럼과, 컬럼이 지니는 데이터 타입을 정의한 것을 의미한다.
릴레이션은 일반 표와는 달리, 레코드의 유일성, 레코드의 무순서성, 컬럼의 무순서성, 컬럼값의 유일성이라는 특징을 갖는다.
기본키는 한 데이터베이스 내에서 레코드를 유일하게 판별할 수 있는 컬럼을 말하며, 카디널리티는 레코드의 개수를 의미한다. 키의 종류로는 기본키, 후보키, 수퍼키 등이 있다.
관계형 모델은 영역 제약조건, 키 제약조건, 개체 무결성 제약조건, 참조 무결성 제약조건이 항상 만족되도록 모든 데이터의 삽입, 수정, 삭제 시 데이터를 검증하며, 이를 통해 데이터의 무결성과 일관성을 유지시킨다.
ER 모델링의 결과를 토대로 실제 상용 DBMS상의 데이터베이스를 만들기 위해서는 각 DBMS에 맞는 구현 데이터 모델로의 변환이 필요하다. 이러한 변환 과정을 논리적 데이터 모델링이라고 한다.
ER 모델에서 관계 데이터 모델로의 변환 시 보통 개체는 릴레이션으로, 약한 개체 집합의 경우 강한 개체의 키를 약한 개체의 부분키와 합쳐서 기본키로 갖는 릴레이션으로 변환 가능하다.
ER 모델에서 관계 데이터 모델로의 변환 시 사상수에 따라 테이블 간 레코드의 연관성을 외래키와 기본키의 참조 관계로 표현한다.
관계 데이터베이스에서는 관계 대수라는 절차적 질의 언어를 사용할 수 있다. 관계 대수 연산에서 릴레이션에 대한 집합 연산으로는 셀렉트, 프로젝트, 합집합, 교집합, 차집합, 카티션 프로덕트 연산 등이 있다.
관계 대수의 또 다른 연산은 자연 조인, 할당 연산자 및 프로젝트 연산과 SUM, AVG, MAX, MIN, COUNT와 같은 집계 함수가 있다.
구조화된 질의 언어(structured query language)라는 의미의 SQL은 사람과 DBMS 간의 의사소통을 위한 대표적인 DBMS 언어이다. SQL에는 데이터 정의 언어와 데이터 조작 언어로 구성되며, 이 외에도 DBMS를 관리하기 위한 다양한 기능을 지원한다.
데이터 정의 언어(DDL)는 데이터베이스, 테이블, 뷰, 인덱스 등의 데이터베이스 객체를 정의하는 데 이용된다. CREATE, ALTER, DROP 명령어를 사용하여 데이터베이스 객체를 생성, 수정, 추가할 수 있다.
스키마는 데이터베이스와 동일한 의미로 사용되며 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합을 의미한다.
CREATE TABLE 문을 사용하여 테이블의 컬럼 정의 시 컬럼이 가질 수 있는 값의 범위를 데이터 타입을 지정하며 문자, 숫자, 날짜에 대한 여러 데이터 타입을 제공한다.
ALTER TABLE 문은 컬럼의 추가 및 삭제, 데이터 타입 변경 등 테이블 수정을 지시한다. 반면 DROP TABLE 문은 테이블의 삭제를 지시한다.
테이블 정의 시 데이터의 일관성과 무결성 유지를 위해 데이터가 가져야 하는 다양한 제약조건을 기술할 수 있으며, 종류로는 PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK, AUTO INCREMENT, DEFAULT 등이 있다.
구조화된 질의 언어(structured query language)라는 의미의 SQL은 사람과 DBMS 간의 의사소통을 위한 대표적인 DBMS 언어이다. SQL에는 데이터 정의 언어와 데이터 조작 언어로 구성되며, 이 외에도 DBMS를 관리하기 위한 다양한 기능을 지원한다.
데이터 정의 언어(DDL)는 데이터베이스, 테이블, 뷰, 인덱스 등의 데이터베이스 객체를 정의하는 데 이용된다. CREATE, ALTER, DROP 명령어를 사용하여 데이터베이스 객체를 생성, 수정, 추가할 수 있다.
스키마는 데이터베이스와 동일한 의미로 사용되며 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합을 의미한다.
CREATE TABLE 문을 사용하여 테이블의 컬럼 정의 시 컬럼이 가질 수 있는 값의 범위를 데이터 타입을 지정하며 문자, 숫자, 날짜에 대한 여러 데이터 타입을 제공한다.
ALTER TABLE 문은 컬럼의 추가 및 삭제, 데이터 타입 변경 등 테이블 수정을 지시한다. 반면 DROP TABLE 문은 테이블의 삭제를 지시한다.
테이블 정의 시 데이터의 일관성과 무결성 유지를 위해 데이터가 가져야 하는 다양한 제약조건을 기술할 수 있으며, 종류로는 PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK, AUTO INCREMENT, DEFAULT 등이 있다.
데이터베이스 모델링 과정에서 효율성을 위해 어떤 속성들을 그룹화하여 테이블로 작성할 것인지 고려할 필요가 있으며 전체적인 테이블 구조는 데이터베이스의 정확성을 판단하는 데 중요한 기준이 된다.
정규화는 데이터의 중복을 제거하고, 새로운 속성들이 데이터베이스에 추가될 때 기존 속성과의 관계에서 수정을 최소화해야 한다는 것이 목적이다. 따라서 정규화 과정을 통해 데이터 저장을 위한 공간의 낭비를 최소화 할 수 있다.
정규화 이전에 데이터베이스 조작에서 발생하는 삽입, 삭제, 수정 등의 갱신 이상 현상을 정규화를 통해 방지할 수 있다.
속성들 간의 연관관계를 표현 한함수적 종속성은 릴레이션의 효율성 여부에 중요한 판단기준이 되지만 릴레이션의 인스턴스만으로 잠재된 모든 함수적 종속성을 찾아내기 어렵기 때문에 이를 확장하기 위해 암스트롱 공리를 적용하여 클로저로 확장한다.
도출된 클로저에는 자명한 함수적 종속성이나 중복된 함수적 종속성을 포함하고 있으므로 이러한 불필요한 종속성을 제거한 카노니컬 커버를 사용하여 정규화를 진행한다.
함수적 종속성은 릴레이션 스키마의 속성들 사이에 명시되는 기본적인 제약조건이다. 함수적 종속성에 의한 방법과 추론하는 방법을 바탕으로 기본적인 정규형을 구성할 수 있다.
정규형의 만족시켜야 하는 제약조건에 따라 제1정규형, 제2정규형, 제3정규형, BC정규형, 제4정규형, 제5정규형 순서로 진행된다. 정규형의 조건은 정규화가 진행될수록 강화되다.

물리적 저장장치들은 데이터 접근 속도 관점에서 계층적으로 분류된다. 상위계층은 접근 속도가 빠르지만 고가의 장비이며, 하위계층은 접근 속도가 느리지만 저가의 장비이다.

일반적으로 상위의 저장장치들은 전원 공급이 차단되면 데이터가 소멸되는 휘발성이며, 하위의 저장장치들은 전원 공급이 차단되어도 데이터가 소멸되지 않는 비휘발성이다.

데이터베이스는 여러 파일로 구현된다. 파일이란 데이터를 영구적으로 저장하기 위해 사용하는 구조이다. 파일은 물리적으로 여러 블럭으로 나뉘어 저장되기도 한다. 하나의 파일은 다수의 레코드를 저장하고 있다.

레코드의 형식은 고정 길이 레코드와 가변 길이 레코드가 있다. 레코드의 형식에 따라 파일 및 블럭에서 레코드를 관리하는 방식이 달라진다. 특히 슬롯 페이지 구조는 가변 길이 레코드를 관리할 때 이용되는 블럭 구조이다.

특정 필드에 대한 빠른 접근이 요구되는 경우, 파일에 저장되는 레코드를 구조화하는 것이 좋다. 파일 구조화 방법으로는 힙 파일 구조화, 순차 파일 구조화, 해시 파일 구조화가 있다. 파일 구조 중 다중 테이블 군집 파일 구조는 여러 개의 테이블을 하나의 파일에서 관리하는 특수한 파일 구조이다.

메모리와 디스크는 블럭 단위로 데이터를 주고받는다. 이때 데이터베이스 시스템에서는 블럭의 입출력을 최소화하기 위해 메모리 내에 버퍼라는 공간을 만들며, 버퍼를 효율적으로 관리하기 위해 버퍼 관리자를 사용한다.

버퍼 관리자는 버퍼 공간에 대한 추가적인 공간 요청 시 버퍼 교체 전략을 사용하여 사용된 블록을 디스크로 내보내어 공간을 확보한다.
데이터베이스 시스템에서는 데이터에 대한 빠른 탐색을 지원하기 위해 인덱싱과 해싱을 이용한다.
인덱스는 데이터 파일에 대한 빠른 탐색을 지원하는 부가적인 자료구조이며 인덱스를 생성하는 작업을 인덱싱이라고 한다.
탐색키의 순서로 정렬된 순차 파일에서는 데이터 레코드에 대한 빠른 임의접근이 가능 하도록 순서 인덱스를 사용할 수 있다.
인덱스는 모든 레코드에 대하여 인덱스 엔트리를 구성하는 밀집 인덱스와, 일부 레코드에 해당하는 인덱스 엔트리를 사용하여 인덱스를 구성하는 희소 인덱스, 밀집 인덱스와 희소 인덱스의 개념을 모두 사용한 다단계 인덱스로 구분할 수 있다.
B+–트리 인덱스는 루트에서 단말(leaf) 노드까지 모든 경로의 길이가 같은 높이 균형 트리로 트리에서 단말 노드나 루트 노드가 아닌 중간(internal) 노드는 ⌈n/2⌉과 n 사이의 자식을 갖는 대표적인 인덱스 구조이다.
B+–트리를 활용한 특정 탐색키 탐색은 루트부터 시작해서 단말 노드에 도달할 때까지 비교연산을 하며 이루어진다. 말단 노드에 도착하면 탐색이 종료된다.
새로운 레코드의 삽입과 삭제 시, B+–트리는 재구조화 된다. B+–트리 구조의 생성 조건을 유지시키기 위해 인덱스 엔트리 삽입과 삭제 시 노드의 분할 및 노드의 병합이 이뤄진다.
해싱은 수학적 함수 개념을 사용한 데이터 관리 기법으로 버킷의 개수가 정해진 정적 해싱과 데이터베이스이 크기에 따라 버킷의 개수가 변경되는 동적 해싱으로 구분된다.

해시 함수는 레코드의 탐색키 값과 저장되어야 하는 버킷의 주소를 대응시키는 역할을 수행하며, 레코드가 버킷에 균등하게 배푼되는 해시 함수가 가장 이상적이다.

충돌 발생으로 서로 다른 탐색키가 동일한 버킷에 대응될 수 있으며 이를 동거자라고 한다. 특정 버킷에 많은 충돌이 발생하여 더 이상의 레코드나 인덱스 엔트리가 저장될 수 없을 때 이를 오버플로라 한다.

확장성 해싱은 데이터베이스의 크기에 따라 버킷이 확장되는 동적 해싱 기법의 일종으로 디렉토리와 버킷으로 구성되며 디렉토리의 주소와 버킷의 주소로 구성되는 모조키를 사용한다.

비트맵 인덱스는 다중키를 가진 질의를 보다 효율적으로 처리하기 위해 고안된 인덱스이다. 비트맵은 간단한 비트 배열로 이루어져 있다.

비트맵 인덱스를 사용하여 레코드를 검색 시 주어진 각각의 조건에 해당하는 비트열을 비트 AND 연산을 수행하여 최종적으로 생성되는 비트열로 조건을 만족하는 레코드의 위치를 빠르게 파악할 수 있다.


동시성 제어는 다수의 트랜잭션이 동시에 동일한 데이터에 대해 읽기 연산을 수행하거나 갱신 연산을 수행하려고 할 때, 데이터의 무결성을 유지하면서도 동시에 실행될 수 있는 트랜잭션의 수를 제어하는 기법이다.

대표적인 동시성 제어 기법에는 락 기반 규약, 타임스탬프 순서 규약, 검증 기반 규약(protocol) 등이 있다.

락(lock)이란 한 트랜잭션이 데이터 항목에 접근하는 동안에는 다른 트랜잭션이 그 데이터 항목에 접근하는 것을 제어하는 기법이다.

락킹 기법에는 공유 락(shared lock)과 배타 락(exclusive lock)이 있다. 공유 락은 양립가능하지만 배타 락은 다른 공유, 배타 락과 양립될 수 없다.

2단계 락킹 규약(two–phase locking protocol)은 각 트랜잭션이 락을 요청하는 단계와 언락을 요청하는 두 단계로 구성되어 있다. 트랜잭션은 요청 단계에서부터 시작되며 필요에 따라서 락을 요청할 수 있다. 만약 트랜잭션이 하나의 락을 반납하게 되면 그때부터 트랜잭션은 반납 단계로 되며 더 이상 락 요청을 할 수 없다.

타임스탬프 순서(timestamp ordering) 기법은 트랜잭션 충돌을 위해 직렬 가능한 순서를 정하는 데 가장 많이 사용하는 방법으로, 시스템의 각 트랜잭션마다 고유한 타임스탬프를 부여한다.

타임스탬프가 직렬 가능성을 보장하므로 TS(T1)＜TS(T2)라면 시스템은 T1을 처리한 후 T2를 처리하여 직렬 스케줄과 동등하도록 보장한다.

데이터 회복이란 데이터베이스 운영 도중에 발생하는 예기치 못한 실패나 고장이 발생한 경우 데이터베이스를 실패 및 고장 발생 이전의 일관적인 상태로 되돌리는 작업을 의미한다.

실패 유형에는 논리적 오류나 버퍼 오버플로 등의 요인에 의한 트랜잭션 실패, 하드웨어 고장 등으로 인한 시스템 장애, 디스크 손상으로 인한 디스크 실패가 있다.

디스크와 주기억장치 사이에 블럭 단위로 데이터가 이동되며 디스크상의 블록은 물리적 블럭, 주기억장치상의 블럭은 버퍼 블록이라고 한다. 데이터베이스 응용에서의 데이터 조작은 버퍼 블럭에서 이루어지며, 트랜잭션 완료나 버퍼의 여유 공간이 없을 때 버퍼 블럭이 디스크에 기록된다.

데이터베이스 회복을 위해 가장 많이 사용되는 로그 기반 회복 기법으로 데이터베이스 시스템가 기록한 모든 수정 작업에 대한 기록을 유사 시 데이터베이스를 이전 상태로 복구하는 데에 사용하는 기법이다.

데이터베이스 회복 시 각각의 트랜잭션은 Redo나 Undo된다. 문제없이 진행되어야 했을 트랜잭션의 경우 Redo되며, 완료되지 못한 상황에서 예기치 않게 종료되어 데이터베이스의 일관성을 해칠 위험이 있는 트랜잭션의 경우 Undo된다.

장기간 데이터베이스 운용으로 시스템 장애 발생 시 재실행해야 할 로그의 양이 방대해지기 때문에 체크포인트를 실행하여 최근의 실행된 체크포인트 이후의 로그만으로도 데이터베이스를 회복할 수 있는 방법을 제공한다.

체크포인트를 생성하는 작업은 메모리에 존재하는 모든 로그 레코드를 안정 저장장치로 기록한 후, 수정된 모든 버퍼 블럭을 디스크에 반영한다. 이후 현재 실행 중인 트랜잭션의 리스트를 표시한 를 안정 저장장치에 기록한다.

회복 과정은 오류 발생 기전까지 트랜잭션의 실행 상태에 따라 Redo 또는 Undo 작업으로 분류된다. 정상적으로 완료된 트랜잭션에 대해서는 Redo를 실행하며 불완전 실행된 트랜잭션은 로그를 역순으로 읽어 트랜잭션 실행 전까지 되돌린다.

체크포인트를 사용하는 시스템에 대해서는 마지막 체크포인트를 확인하고 그 이후의 로그에 대해서만 정상적으로 반영되었는지 확인하여 Redo 또는 Undo하면 무결한 데이터베이스를 유지할 수 있다.



[운영체제]
운영체제는 컴퓨터 시스템의 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 프로그램들의 모습으로 대표적인 시스템 소프트웨어이다.

커널 모드는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드이고, 사용자 모드는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 없는 모드이다.

응용 프로그램은 사용자 모드에서 동작하기에, 하드웨어에 대한 제어가 필요한 경우 시스템 호출을 통해 필요한 서비스를 운영체제에 요청해야 한다.

운영체제의 주요 구성요소에는 프로세스 관리자, 메모리 관리자, 장치관리자, 파일 관리자가 있다.

운영체제의 대표적인 유형으로는 일괄처리 운영체제, 시분할 운영체제, 실시간 운영체제, 분산 운영체제가 있다.

프로세스는 실행 중인 프로그램을 의미하며, CPU, 메모리, 파일, 입출력장치 등 실행에 필요한 자원이 할당된다.

프로세스 제어 블록은 프로세스를 명시해 주는 다양한 내용을 포함하고 있다.

프로세스는 생성, 준비, 실행, 대기, 종료의 다섯 상태 중 하나로 존재하며, CPU의 스케줄링, 입출력 대기 등에 따라 준비, 실행, 대기 등으로 상태가 변화되며 동작한다.

쓰레드는 프로세스에서 실행의 개념만 분리한 것으로 디스패칭의 단위이다.

하나의 프로세스 내에는 하나 이상의 쓰레드가 있을 수 있어, 다중 쓰레드를 생성하여 프로세스 내에서의 다중처리를 할 수 있다.

프로세스의 스케줄링을 위해 상위단계, 하위단계 및 중간단계 스케줄링이 사용된다.

선점 스케줄링 정책은 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식이고, 비선점 스케줄링 정책은 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식이다.

FCFS 스케줄링은 준비 큐에 도착한 순서에 따라 디스패치하는 비선점 방식의 스케줄링 알고리즘이다.

SJF 스케줄링은 준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 비선점 방식의 스케줄링 알고리즘이다.

SRT 스케줄링은 준비 큐에서 기다리는 프로세스 중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 선점 방식의 알고리즘이다.

RR 스케줄링은 프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량에 의해 실행을 제한하는 선점 방식의 스케줄링 알고리즘이다.

HRN 스케줄링은 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치하여 실행하는 비선점 방식의 스케줄링 알고리즘이다.

HRN 스케줄링의 응답비율은 예상실행시간이 짧을수록, 그리고 대기시간이 길수록 커진다.

다단계 피드백 큐 스케줄링은 입출력 위주의 프로세스가 연산 위주의 프로세스보다 우선권을 갖도록 하는 선점 방식의 알고리즘이다.

[정보통신망]
변조 : 메시지를 통신 매체를 통해 전달하고자 할 때에는 우선 가장 작은 단위의 정보인 비트를 통신 매체에 맞는 신호로 바꾸어 주어야 한다. 이때 필요한 과정, 즉 전송 신호를 높은 주파수 대역의 반송파 신호에 싣는 과정을 변조라고 한다.
복조 : 통신에서는 기본파로서의 고주파에 화상이나 음성 등의 신호에 따라 변화시킨 변조파를 실어서 송신하며, 수신기에서는 고주파 전류로부터 변조파를 꺼내서 원래의 신호로 복구하는 조작을 하게 되는데 이를 복조라 한다.
전송 코드 : 통신 회선을 경유하며 정보를 전송하기 위해 사용되는 코드. 즉, 사람이 표현하고자 하는 개념을 숫자나 문자로 표현하는데, 데이터 통신을 통해 개념을 송수신하고자 할 때 필요한 문자에 대응하는 코드를 위미한다.
전이중 전송 : 양단의 단말기가 동시에 데이터를 전송하고 받을 수 있도록 하여, 전체 시스템이 양방향의 데이터 흐름을 가지는 것
병렬전송 : 부호화된 코드의 모든 비트가 동시에 전송하며, 근거리 데이터 전송에 사용
비트 동기 : 직렬전송의 경우 송신측에서 보내온 비트 패턴을 수신측에서 올바르게 해석하기 위해 송,수신측에 동일한 클록을 사용하여 동기화 하는 방법
동기식 전송 : 전송제어 문자를 사용하여 데이터 블록을 한꺼번에 전송
비동기식 전송 : 한 문자씩 전송하며, 문자 사이에는 특별한 시간적 제약이 없음
전송효율 : 통신선의 사용 효율, 총 전송 비트 수에 대한 정보 비트수를 백분율(%)로 표시

점대점 선로 : 점대점으로 두 단말기를 연결하는 통신선로

집선 : 전화 교환망과 같이 다수 회선으로부터의 호출을 집약하여 그보다 적은 수의 중계선으로 전송하는 것

전송매체 : 컴퓨터 통신망에서 수신기와 송신기 간에 물리적인 데이터 전송로, 매체의 특성에 따라 하드와이어 매체와 소프트와이어 매체로 구분

꼬임선 케이블 : 두 가닥의 절연된 구리선이 균일하게 꼬여있는 것으로 하나의 쌍이 하나의 통신선로의 역할을 수행

성형 네트워크 : 각 단말기가 점 대 점 선로에 의하여 중앙 컴퓨터로 연결되고 중앙 컴퓨터의 의존도가 높음

브리지 : 복수의 LAN을 연결하기 위한 장치, 데이터링크 계층에서 동작

Routing 기능 : 송신지에서 수신지로 가장 최적의 경로를 선택하여 데이터 패킷을 전송

네트워크 애플리케이션 : 네트워크를 통해 데이터를 보내고 전송된 데이터를 받는 것을 담당하는 소프트웨어

NOS : Network Operating System으로 통신 장비들을 운영하고 제어

회선(circuit) : 설정된 통신경로의 집합

회선 교환 : 호스트들 간에 통신을 제공하기 위해 경로 상에 필요한 자원들을 미리 할당하고 할당된 자원을 이용하여 데이터를 전송하며, 데이터 전송이 종료되면 할당된 자원을 해제

연결지향형 전송 : 연결지향형 전송(connection-oriented transmission)은 물리적 또는 논리적으로 회선을 만들어 전용선처럼 사용하는 방법으로 다음 3가지 단계를 거쳐 동작한다: ① 연결 설정(connection establishment), ② 데이터 전송(data transmission), ③ 연결 해제(connection termination).

패킷 교환 : 송·수신자 간에 전용선이 제공되지 않으며, 모든 전송 데이터가 패킷 형태로 분할되어 전송

가상 회선 : 회선 교환에서의 독점 형태의 회선은 아니지만, 송·수신자 간에 전송되는 논리적 경로

데이터그램 : 논리적 경로를 설정하지 않고 각기 독립적으로 전송되는 패킷

메시지 교환 : 하나의 메시지 단위로 저장 후 전송 방식에 의해 데이터를 교환하는 방식

다중화 : 여러 단말기들이 통신선로의 용량을 나누어 쓸 수 있도록 해주는 투명한 장치

주소지정 : 컴퓨터통신망에서 사용자를 식별하는 방법

물리주소 : MAC 주소라고 부르며 TCP/IP의 데이터링크 계층에서 사용, 48비트를 8비트 단위로 콜론(:)으로 구분하여 16진수로 표현

논리주소 : IP 주소라고 부르며 TCP/IP의 IP 계층에서 사용, 32비트를 8비트 단위로 점(.)으로 구분하여 10진수로 표현

잔류오류율(RER) : 오류로 전달된 비트 수와 전송된 전체 비트 수와의 비율(Residual Error Rate)

오류제어 : 잡음, 고장 등의 영향에 대비하여 RER을 주어진 한계 이내로 유지하는 통신 기능

패리티 검사 : 각 문자 내의 비트 수를 전송 전에 검사하여 패리티 비트를 포함한 전체 비트에서 ‘1’의 개수가 홀수(odd parity)나 짝수(even parity)가 되도록 패리티 비트라는 1개의 비트를 더해 주는 것

ARQ : 전송로에서 발생하는 데이터의 오류를 송신 측 또는 수신 측에서 검출하고, 데이터에 오류가 있는 경우에 재전송을 요구하는 방식으로 정지-대기 ARQ, 연속적 ARQ, 적응적 ARQ 등이 있음.

주소지정 : 컴퓨터통신망에서 사용자를 식별하는 방법

물리주소 : MAC 주소라고 부르며 TCP/IP의 데이터링크 계층에서 사용, 48비트를 8비트 단위로 콜론(:)으로 구분하여 16진수로 표현

논리주소 : IP 주소라고 부르며 TCP/IP의 IP 계층에서 사용, 32비트를 8비트 단위로 점(.)으로 구분하여 10진수로 표현

잔류오류율(RER) : 오류로 전달된 비트 수와 전송된 전체 비트 수와의 비율(Residual Error Rate)

오류제어 : 잡음, 고장 등의 영향에 대비하여 RER을 주어진 한계 이내로 유지하는 통신 기능

패리티 검사 : 각 문자 내의 비트 수를 전송 전에 검사하여 패리티 비트를 포함한 전체 비트에서 ‘1’의 개수가 홀수(odd parity)나 짝수(even parity)가 되도록 패리티 비트라는 1개의 비트를 더해 주는 것

ARQ : 전송로에서 발생하는 데이터의 오류를 송신 측 또는 수신 측에서 검출하고, 데이터에 오류가 있는 경우에 재전송을 요구하는 방식으로 정지-대기 ARQ, 연속적 ARQ, 적응적 ARQ 등이 있음.








[유비쿼터스 컴퓨팅개론]
유비쿼터스환경
언제, 어디서나, 어떠한 통신 단말기를 가지고, 어느 정보통신망을 통해서든, 원하는 정보통신 서비스를 받을 수 있는환경

유비쿼터스혁명
서로 이질적인 물리공간(제1공간)과 전자공간(제2공간)이 제3의 가치공간인 유비쿼터스공간으로 통합/진화되는 것

유비쿼터스컴퓨팅 개념을 토대로 하는 접근 방법
① 물리공간의 사물 이지미를 해석하여 사용자의 주변을 분석하고 주위의 특정 사물의 존재를 컴퓨터가 인식할 수 있도록 함 ② 다양한 컴퓨터(칩, 센서, 태그, 구동체등)를 사물 속에 심고 이들을 네트워크로 연결하여 물리공간의 상황을 사물과 사물, 사물과 컴퓨터, 컴퓨터와 사물 간의 상호작용을 통해 유비쿼터스공간(전자공간-물리공간)으로 인식함

유비쿼터스공간
만지지 않아도 공간에 존재하거나 공간에 관한 정보를 사용자가 알 수 있는 ‘현실체가지능적으로 증강된 공간’으로인식함

유비쿼터스 컴퓨팅
사람을 포함한 현실공간에 존재하는 모든 대상물들을 기능적·공간적으로 연결하여 사용자에게 필요한 정보나 서비스를 즉시에 제공할 수 있는 기반 기술
⇒사물의 일부가 된 컴퓨터들은 주변 상황을 인식할 수 있고, 지리적으로 떨어진 곳에서도 사용자가대상 사물과 그 주변 환경의 변화를 지각하거나 추적할 수 있도록 함

유비쿼터스 컴퓨팅의 특징
① 네트워크에 연결되지 않은 컴퓨터는 유비쿼터스 컴퓨팅이 아니다.
② 인간 중심의 인터페이스로서 눈에 보이지 않아야 한다.
③ 현실 세계의 어디서나 컴퓨터의 사용이 가능해야 한다.

유비쿼터스 컴퓨팅의 개념적 기술전개 예측
① 유비쿼터스 네트워크
② 유비쿼터스 기술의 인간 친화
③ 사용자에 최적화된 서비스 환경
④ 지능화된 사물

유비쿼터스 컴퓨팅 기술 이슈
① 복잡하고 방대한 결과에 대한 시각적 편리성을 지향하며, 정보서비스 제공이 구체화되어야 한다.
② 구체화된 컴퓨터의 운영체제, 응용 등에 대한 협력 작업과 분산 작업을 통한 효율적인 협력 시스템과 서로 다른 기능을 갖는 다양한 시스템들의 융합 컴퓨팅 모델이 제시되어야 한다.
③ 나노 기술이나 병렬 시스템 등의 기술을 통해 가상화나 클러스터링 기술을 통해 스마트폰이나 PC를 단말기로 사용하는 슈퍼컴퓨터 사용 환경을 제공한다.
④ 인터넷 통신 속도의 고속화, 안정성, 효율성, 광대역 채널의 확보를 통해 데이터나 컴퓨팅 능력면에서 보다 큰 스케일의 컴퓨팅 공간을 구축해야 한다.
⑤ 인간중심의 사용자 인터페이스를 통해 편리한 인터페이스를 제공하기도 하고, 개인화된 인터페이스를 제공할 수 있는 서비스가 창출해야 한다.

사물(Objects)
네트워크에 연결된 다양한 디바이스(장치)이며, 임의의 소형 처리장치가 부착된 일종의 임베디드 시스템

사물(Objects)의 구성요소
- 주변 상황을 인지하고 필요한 데이터를 수집할 수 있는 센서
- 수집한 데이터를 처리하거나 저장할 수 있는 처리기(프로세서)및 저장공간
- 인터넷 망과 연결하여 데이터를 주고받을 수 있는 통신모듈
- 자체 전원 혹은 외부 전원

IoT
- 사물(센서), 네트워크, 데이터, 서비스의 융합
- 사물에 설치된 센서를 이용하여 데이터를 수집하고, 네트워크를 통해 수집한 데이터를 전송하며, 수집한 데이터를 가공하여 새로운 서비스를제공함

IoT 플랫폼이 갖추어야 할 기능
- 이기종 센서들에 대한 식별 및 연결 기능
- 각 사물에 대한 제어 기능
- 다수의 센서들로부터수집된 데이터에 대한 효율적인저장 및 관리 기능
- 수집된 대용량 데이터에 대한 효율적인 검색 및 분석 기능
- 웹을 통한 개방형 서비스 제공 기능

SoC 기술
칩 자체가 하나의 시스템으로 기능할 수 있도록 정보통신기기의 핵심기능을 담당하는 메모리, 디지털 회로, 아날로그 회로, CPU, 센서, 안테나, 수동소자 등을 하나의 반도체 칩에 집적하는 기술

SoC 개발의 기술적 한계
① 게이트의 숫자에 의한 구현의 어려움
② DRAM과 SRAM의 포함에 따른 구현의 경제성
③ 아날로그 방식 칩에 대한 효과의 약점

미세 전자기계 시스템(MEMS)
유비쿼터스 네트워크나 초소형 휴먼 인터페이스 분야의 핵심요소인 3차원 미소 구조물, 센서 및 구동 장치 등을 소형화 및 고정밀화하고 복합화를 가능하게 하는 시스템화 기술

[이산수학]
관계
두 집합 X와 Y가 존재하고 X에서 Y로의 관계 R이 있을 때, R은 이들의 곱집합 X×Y의 부분집합이다. 만약 x와 y가 각각 X와 Y의 원소이고 (x, y)∈R이면 xRy로 표기하며, x는 y와 R의 관계가 있다라고 한다. 두 집합 X와 Y가 X=Y를 만족하면 이들 사이의 관계 R을 X에서의 관계라고 한다.
[정의 6.1]
[참고] http://en.wikipedia.org/wiki/Relation_(mathematics)

관계의 성질(반사적, 대칭적, 추이적)
집합 A에 대한 관계 R이 있을 때,
(1) 모든 a∈A에 대해 aRa이면 반사적이라 한다.
(2) 모든 a,b∈A에 대해 aRb→bRa 가 성립하는 경우 관계 R은 대칭적이라 한다.
(3) 모든 a,b,c∈A에 대해 (aRb∧bRc)→aRc가 성립하는 경우 관계 R은 추이적이라고 한다.
[정의 6.2]
[참고] http://en.wikipedia.org/wiki/Reflexive_relation
http://en.wikipedia.org/wiki/Symmetric_relation
http://en.wikipedia.org/wiki/Transitive_relation

역관계
집합 X에서 집합 Y로의 관계 R이 있을 때, 관계를 구성하는 각 순서쌍의 원소 순서를 바꾸면 Y에서 X로의 관계가 되며, 이를 역관계라고 한다. 기호로 R⁻¹이라 표기하며 다음과 같이 정의한다.
R⁻¹={(y,x)∣(x,y)∈R}
[정의 6.3]
[참고] http://en.wikipedia.org/wiki/Inverse_relation

합성관계
집합 A에서 집합 B로의 관계 R이 있고, 집합 B에서 집합 C로의 관계 S가 있을 때,
S ∙ R={(a,c)∈A×C ∣ a∈A,b∈B,c∈C,(a,b)∈R,(b,c)∈S}로 정의되는 A에서 C로의 관계를 합성관계라 한다.
[정의 6.4]
[참고] http://en.wikipedia.org/wiki/Composition_of_relations

동치관계
집합 A에 대한 관계 R이 있을 때, R이 반사적이고, 대칭적이고, 추이적이면 R은 동치관계이다.
[정의 6.5]
[참고] http://en.wikipedia.org/wiki/Equivalence_relation

동치류
집합 A에 대한 관계 R이 있을 때, A의 각 원소 a에 대하여 a의 동치류는 a와 R의 관계를 가지는 A의 원소들의 집합이며, [a]로 표기한다. 기호로 나타내면
[a]={x∈A∣xRa} 또는 [a]={x∈A∣aRx} 이다.
[정의 6.6]
[참고] http://en.wikipedia.org/wiki/Equivalence_class

명제(Discrete mathematics)
[정의2.1]
참과 거짓을 구별할 수 있는 문장이나 수학적 식
추가설명 - 합성명제, 조건명제, 쌍조건명제, 항진명제, 모순명제 등의 의미도 확인하기바람.
[참고] http://en.wikipedia.org/wiki/Discrete_mathematics

논리적 동치
어떤 주어진 문제를 수학적 표현(방정식)으로 변환하는 것이다.
[정의 2.7]
두 명제 𝒑 와 𝒒 가 논리적으로 동등하면 논리적 동치라고 하고, 𝒑≡𝒒 로 표시한다.
[참고] http://en.wikipedia.org/wiki/Abstraction

명제함수(propositional function)
[정의 2.9]
변수의 값에 의해 함수의 진리값이 결정되는 문장이나 식
[참고] http://en.wikipedia.org/wiki/Algorithm

추론(inference)
[정의 2.12]
참으로 알려진 명제를 기초로 하여 다른 명제를 유도해 내는 과정을 추론이라고 한다.

그래프
그래프는 꼭지점(vertex)의 집합과 변(edge)의 집합으로 정의된다. 꼭지점 집합 V와 변의 집합 E를 가지는 그래프 G는 G=(V, E)와 같이 표현한다. 변은 두 꼭지점을 연결하는 역할을 수행하는데, 만일 변 e가 꼭지점 v와 w를 연결하는 경우 v와 w는 e에 의해 발생(incident)되었다고 하고, 연결된 두 꼭지점 v와 w는 서로 인접(adjacent)한다고 한다. 동일한 꼭지점을 연결하는 변은 특별히 루프(loop)라 한다. 동일한 두 꼭지점을 연결하는 변이 두 개 이상 있을 대 이러한 변들을 병렬(parallel) 변이라 한다. 어떠한 변도 연결되지 않은 꼭지점은 고립(isolated)되었다고 한다.
[정의 9.1]
[참고] http://en.wikipedia.org/wiki/Graph_(mathematics)

방향 그래프
그래프의 변이 방향을 가지고 있으면 방향 그래프(directed graph)라 하고, 변이 방향을 가지지 않는 그래프를 무향 그래프(undirected graph)라 한다.
[정의 9.2]
[참고] http://en.wikipedia.org/wiki/Graph_(mathematics)

단순 그래프
꼭지점의 집합 V와 변의 집합 E로 이루어진 단순 그래프 G=(V, E) 는 두 개의 꼭지점 사이에 최대 하나의 변을 가지는 무향 그래프이다. 다시 말하면, 어떤 루프나 어떠한 병렬 변을 가지지 않는 그래프이다.
[정의 9.3]
[참고] http://en.wikipedia.org/wiki/Graph_(mathematics)

부분 그래프
그래프 H와 그래프 G가 있을 때, H의 모든 꼭지점이 G의 꼭지점이고, H의 모든 변이 G의 변일 경우 H를 G의 부분 그래프라고 한다. 만약, H의 꼭지점과 G의 꼭지점이 완전히 일치하면 H는 G의 신장 부분 그래프라 한다.
즉, H=(V, E)이고, G=(V’, E’)일 때,
(1) 부분그래프는 V’ ⊆ V 이고 E’ ⊆ E 인 그래프이고,
(2) 신장 부분 그래프는 V’ = V 이고 E’ ⊆ E 인 그래프이다.
[정의 9.4]
[참고] http://en.wikipedia.org/wiki/Spanning_subgraph#Subgraphs

그래프의 차수
그래프 G의 꼭지점 v에 대해 v에 인접한 변의 수를 v의 차수라 한다. 변이 루프일 경우 2를 더한다. G의 총 차수는 G에 있는 모든 꼭지점 차수의 합이다.
[정의 9.5]
[참고] http://en.wikipedia.org/wiki/Degree_(graph_theory)

워크, 트레일, 경로
[정의 9.6]
[참고] http://en.wikipedia.org/wiki/Path_(graph_theory)

연결 그래프
그래프에서 두 꼭지점을 서로 연결하는 경로가 있을 경우, 두 꼭지점은 서로 연결되어 있다고 한다. V의 꼭지점들은 서로 연결되고 다른 집합과 겹치지 않는 꼭지점의 집합 V₁, V₂ ..., Vₘ 로 나눌 수 있는데, 이들 각각을 연결 성분이라 한다. 그래프에 오직 하나의 연결된 요소만 있을 경우를 연결 그래프라고 한다.
[정의 9.8]
[참고]http://en.wikipedia.org/wiki/Connected_graph

완전 그래프
그래프에 속한 모든 꼭지점이 다른 꼭지점과 인접할 경우 완전 그래프라 하고, n개의 꼭지점을 가지는 완전 그래프는 Kₙ 으로 나타낸다.
[정의 9.9]
[참고] http://en.wikipedia.org/wiki/Complete_graph

이분 그래프
그래프 G=(V, E)의 V가 연결성분 V₁과 V₂로 분할되어 있고, 모든 변들이 V₁의 꼭지점과 V₂의 꼭지점을 연결할 경우 이분 그래프라고 한다.
[정의 9.10]
[참고] http://en.wikipedia.org/wiki/Bipartite_graph

정규 그래프
그래프 G=(V, E)의 모든 꼭지점들이 동일한 수의 이웃을 가질 경우, 정규 그래프라 한다. 즉, 정규 그래프의 모든 꼭지점들은 동일한 차수를 가지며, 각 꼭지점이 k의 차수를 가진다면 k-정규 그래프라고 한다. 0-정규 그래프는 변이 없는 그래프이고, 1-정규 그래프는 독립된 꼭지점으로 이루어진 그래프이며, 2정규 그래프는 사이클로 구성된 그래프이다. 3-정규 그래프는 큐빅 그래프라고도 부른다.
[정의 9.12]
[참고] http://en.wikipedia.org/wiki/Regular_graph

발생 행렬
그래프의 꼭지점을 행렬의 행으로 변을 행렬의 열로 하여, 꼭지점과 변의 연결관계를 표현한 것이 발생행렬이다. 변과 꼭지점 사이에 인접관계에 있을 경우 1의 원소를, 인접관계가 아닐 경우 0의 원소를 가진다. 그래프의 행의 꼭지점의 개수가 │V│개, 열의 개수가│E│개 있을 경우 │V│×│E│크기의 행렬이 만들어진다.
[정의 9.13]
[참고] http://en.wikipedia.org/wiki/Incidence_matrix

인접 행렬
그래프의 꼭지점을 행렬의 행과 열로 하여 꼭지점들 사이의 연결관계를 표현한 것이 인접행렬이다. 꼭지점 Vi,에서 Vj로의 연결개수가 행렬의 (i,j) 원소의 값이 되며, 그래프에서 행의 꼭지점의 개수가 │V│개일 경우, │V│×│V│크기의 행렬이 만들어진다. 무향 단순 그래프의 경우 인접행렬로 표현하면 모든 원소는 0 또는 1의 값을 가지게 되고, 대각원소는 0의 값을 가진다.
[정의 9.14]
[참고] http://en.wikipedia.org/wiki/Adjacency_matrix

인접 리스트
그래프 G=(V, E')의 각 꼭지점에 인접하는 꼭지점들을 차례로 연결 리스트로 표현한 것을 인접 리스트(adjacency list)라 한다.
[정의 9.15]
[참고] http://en.wikipedia.org/wiki/Adjacency_list

