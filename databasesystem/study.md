[데이터베이스시스템]


기존 전산 시스템, 스마트 기기, 소셜 미디어, IoT 센서 등 사회 트렌드의 변화로 대량의 데이터가 저장 및 활용되고 있어 데이터 관리가 점차 중요해지고 있다.
파일 처리 시스템은 프로그램이 직접 데이터에 접근하여 데이터를 저장 및 사용하는 데이터의 중복성, 데이터의 종속성, 데이터의 무결성 훼손, 그리고 동시 접근 이상의 문제점을 내포한다.
데이터베이스는 파일 처리 시스템과 달리 자기 기술성, 추상화, 다중 뷰, 동시성 제어 등의 기능을 통해 파일 처리 시스템의 문제점을 극복한다.
데이터베이스 시스템은 3단계 구조, 즉 외부 단계, 개념 단계 그리고 내부 단계로 구성된다. 외부 단계는 사용자 뷰를 나타내며, 개념 단계는 데이터베이스의 논리적인 전체 구조를 나타내고, 내부 단계는 데이터가 기억장소에 저장되기 위한 물리적 구조를 정의한다.
각 단계 간의 접속에서 특정 외부 스키마와 개념 스키마 간의 대응 관계를 정의한 외부-개념 사상과, 개념 스키마와 내부 스키마 간의 대응 관계를 정의한 개념-내부 사상에 의해 연관성을 갖는다.
데이터베이스 언어란 데이베이스 사용을 위한 언어 형태의 인터페이스로 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로 구성된다.
DBMS는 전체 시스템을 구성하는 방식에 따라 중앙집중식과 분스산 시스템 방식으로 아키텍처를 구성할 수 있다.
데이터베이스 모델링 과정은 사용자 요구사항을 분석하여 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링의 단계로 진행된다.
사용자 요구사항 분석 단계에서는 요구사항을 도출하고 분석하고 기록하는 단계로 진행되며, 요구사항이 모호하거나 정확하지 않을 때는 이전 단계로 회귀하여 요구사항을 교정한다.
데이터 모델링이란 데이터에 대한 요구사항을 정의하고 분석하는 방법으로, 데이터 모델링을 통하여 데이터베이스가 구축되기까지는 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링 과정으로 나뉜다.
ER 모델은 전체적인 데이터베이스의 논리적인 구조를 표현하는 전체 스키마의 명세서를 작성하는데 사용되는 개념적 데이터 모델링 도구로, 실세계의 조직 업무의 의미와 상호작용을 개념적으로 나타내는 데 매우 유용하다.
ER 모델의 기본 요소인 개체는 공통된 속성을 가지며 구별 가능한 실세계의 개체들로 구성된다. 이러한 개체들은 각 개체 집합의 구성원들이 가지는 기술적 특성인 속성들의 집합으로 표현되며, 속성의 유형은 단순 속성, 복합 속성, 단일값 속성, 다중값 속성, 유도 속성, 저장 속성, 널 속성 등으로 구분할 수 있다.
ER 모델의 중요한 제약조건은 사상수, 참가 제약조건, 키 속성으로 나뉘며, 이진 관계에서 사상수 비율은 1：1(일대일), 1：N(일대다), N：1(다대일), M：N(다대다)의 형태가 있다.
참가 제약조건에서는 특정 개체 집합이 관계 집합에 참여할 때 모든 개체가 관계에 참여한다면 전체적 참여, 일부만 참가하면 부분적 참여라고 한다. 또한 구조적 제약조건을 통해 개체가 최소 몇 번, 최대 몇 번 관계에 참여할 수 있는지 정의할 수 있다.
키 속성의 경우 어떤 개체 집합 안의 각각의 개체들을 구별해 주기 위해 선택되는 것으로, 최소한의 속성의 조합으로 만들어지며, 대표적으로 사용될 수 있는 속성 조합을 키라고 한다.
동일한 개체 집합이 서로 다른 역할로 참가하여 생성되는 관계 집합을 재귀적 관계 집합이라고 한다. 이때 관계에 참가하는 개체가 행하는 기능을 개체의 역할(role)이라고 한다.
약한 개체 집합은 1：N 관계 집합을 통해 강한 개체 집합에 연결해야 하며, 약한 개체 집합의 구별자(또는 부분키)는 약한 개체 집합 내의 개체들을 구분하는 속성의 집합이다. 따라서 약한 개체 집합의 키 설정은 반드시 지배 개체 집합의 키와 약한 개체 집합의 부분키로 구성되어야 한다.
관계형 모델은 표와 매우 유사한 구조인 릴레이션에 기초한다. 레코드는 릴레이션의 각 행을 의미하며, 컬럼은 각 열을 의미한다. 이때 릴레이션 스키마란 어떠한 테이블에서 사용되는 컬럼과, 컬럼이 지니는 데이터 타입을 정의한 것을 의미한다.
릴레이션은 일반 표와는 달리, 레코드의 유일성, 레코드의 무순서성, 컬럼의 무순서성, 컬럼값의 유일성이라는 특징을 갖는다.
기본키는 한 데이터베이스 내에서 레코드를 유일하게 판별할 수 있는 컬럼을 말하며, 카디널리티는 레코드의 개수를 의미한다. 키의 종류로는 기본키, 후보키, 수퍼키 등이 있다.
관계형 모델은 영역 제약조건, 키 제약조건, 개체 무결성 제약조건, 참조 무결성 제약조건이 항상 만족되도록 모든 데이터의 삽입, 수정, 삭제 시 데이터를 검증하며, 이를 통해 데이터의 무결성과 일관성을 유지시킨다.
ER 모델링의 결과를 토대로 실제 상용 DBMS상의 데이터베이스를 만들기 위해서는 각 DBMS에 맞는 구현 데이터 모델로의 변환이 필요하다. 이러한 변환 과정을 논리적 데이터 모델링이라고 한다.
ER 모델에서 관계 데이터 모델로의 변환 시 보통 개체는 릴레이션으로, 약한 개체 집합의 경우 강한 개체의 키를 약한 개체의 부분키와 합쳐서 기본키로 갖는 릴레이션으로 변환 가능하다.
ER 모델에서 관계 데이터 모델로의 변환 시 사상수에 따라 테이블 간 레코드의 연관성을 외래키와 기본키의 참조 관계로 표현한다.
관계 데이터베이스에서는 관계 대수라는 절차적 질의 언어를 사용할 수 있다. 관계 대수 연산에서 릴레이션에 대한 집합 연산으로는 셀렉트, 프로젝트, 합집합, 교집합, 차집합, 카티션 프로덕트 연산 등이 있다.
관계 대수의 또 다른 연산은 자연 조인, 할당 연산자 및 프로젝트 연산과 SUM, AVG, MAX, MIN, COUNT와 같은 집계 함수가 있다.
구조화된 질의 언어(structured query language)라는 의미의 SQL은 사람과 DBMS 간의 의사소통을 위한 대표적인 DBMS 언어이다. SQL에는 데이터 정의 언어와 데이터 조작 언어로 구성되며, 이 외에도 DBMS를 관리하기 위한 다양한 기능을 지원한다.
데이터 정의 언어(DDL)는 데이터베이스, 테이블, 뷰, 인덱스 등의 데이터베이스 객체를 정의하는 데 이용된다. CREATE, ALTER, DROP 명령어를 사용하여 데이터베이스 객체를 생성, 수정, 추가할 수 있다.
스키마는 데이터베이스와 동일한 의미로 사용되며 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합을 의미한다.
CREATE TABLE 문을 사용하여 테이블의 컬럼 정의 시 컬럼이 가질 수 있는 값의 범위를 데이터 타입을 지정하며 문자, 숫자, 날짜에 대한 여러 데이터 타입을 제공한다.
ALTER TABLE 문은 컬럼의 추가 및 삭제, 데이터 타입 변경 등 테이블 수정을 지시한다. 반면 DROP TABLE 문은 테이블의 삭제를 지시한다.
테이블 정의 시 데이터의 일관성과 무결성 유지를 위해 데이터가 가져야 하는 다양한 제약조건을 기술할 수 있으며, 종류로는 PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK, AUTO INCREMENT, DEFAULT 등이 있다.
구조화된 질의 언어(structured query language)라는 의미의 SQL은 사람과 DBMS 간의 의사소통을 위한 대표적인 DBMS 언어이다. SQL에는 데이터 정의 언어와 데이터 조작 언어로 구성되며, 이 외에도 DBMS를 관리하기 위한 다양한 기능을 지원한다.
데이터 정의 언어(DDL)는 데이터베이스, 테이블, 뷰, 인덱스 등의 데이터베이스 객체를 정의하는 데 이용된다. CREATE, ALTER, DROP 명령어를 사용하여 데이터베이스 객체를 생성, 수정, 추가할 수 있다.
스키마는 데이터베이스와 동일한 의미로 사용되며 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합을 의미한다.
CREATE TABLE 문을 사용하여 테이블의 컬럼 정의 시 컬럼이 가질 수 있는 값의 범위를 데이터 타입을 지정하며 문자, 숫자, 날짜에 대한 여러 데이터 타입을 제공한다.
ALTER TABLE 문은 컬럼의 추가 및 삭제, 데이터 타입 변경 등 테이블 수정을 지시한다. 반면 DROP TABLE 문은 테이블의 삭제를 지시한다.
테이블 정의 시 데이터의 일관성과 무결성 유지를 위해 데이터가 가져야 하는 다양한 제약조건을 기술할 수 있으며, 종류로는 PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK, AUTO INCREMENT, DEFAULT 등이 있다.
데이터베이스 모델링 과정에서 효율성을 위해 어떤 속성들을 그룹화하여 테이블로 작성할 것인지 고려할 필요가 있으며 전체적인 테이블 구조는 데이터베이스의 정확성을 판단하는 데 중요한 기준이 된다.
정규화는 데이터의 중복을 제거하고, 새로운 속성들이 데이터베이스에 추가될 때 기존 속성과의 관계에서 수정을 최소화해야 한다는 것이 목적이다. 따라서 정규화 과정을 통해 데이터 저장을 위한 공간의 낭비를 최소화 할 수 있다.
정규화 이전에 데이터베이스 조작에서 발생하는 삽입, 삭제, 수정 등의 갱신 이상 현상을 정규화를 통해 방지할 수 있다.
속성들 간의 연관관계를 표현 한함수적 종속성은 릴레이션의 효율성 여부에 중요한 판단기준이 되지만 릴레이션의 인스턴스만으로 잠재된 모든 함수적 종속성을 찾아내기 어렵기 때문에 이를 확장하기 위해 암스트롱 공리를 적용하여 클로저로 확장한다.
도출된 클로저에는 자명한 함수적 종속성이나 중복된 함수적 종속성을 포함하고 있으므로 이러한 불필요한 종속성을 제거한 카노니컬 커버를 사용하여 정규화를 진행한다.
함수적 종속성은 릴레이션 스키마의 속성들 사이에 명시되는 기본적인 제약조건이다. 함수적 종속성에 의한 방법과 추론하는 방법을 바탕으로 기본적인 정규형을 구성할 수 있다.
정규형의 만족시켜야 하는 제약조건에 따라 제1정규형, 제2정규형, 제3정규형, BC정규형, 제4정규형, 제5정규형 순서로 진행된다. 정규형의 조건은 정규화가 진행될수록 강화되다.

물리적 저장장치들은 데이터 접근 속도 관점에서 계층적으로 분류된다. 상위계층은 접근 속도가 빠르지만 고가의 장비이며, 하위계층은 접근 속도가 느리지만 저가의 장비이다.

일반적으로 상위의 저장장치들은 전원 공급이 차단되면 데이터가 소멸되는 휘발성이며, 하위의 저장장치들은 전원 공급이 차단되어도 데이터가 소멸되지 않는 비휘발성이다.

데이터베이스는 여러 파일로 구현된다. 파일이란 데이터를 영구적으로 저장하기 위해 사용하는 구조이다. 파일은 물리적으로 여러 블럭으로 나뉘어 저장되기도 한다. 하나의 파일은 다수의 레코드를 저장하고 있다.

레코드의 형식은 고정 길이 레코드와 가변 길이 레코드가 있다. 레코드의 형식에 따라 파일 및 블럭에서 레코드를 관리하는 방식이 달라진다. 특히 슬롯 페이지 구조는 가변 길이 레코드를 관리할 때 이용되는 블럭 구조이다.

특정 필드에 대한 빠른 접근이 요구되는 경우, 파일에 저장되는 레코드를 구조화하는 것이 좋다. 파일 구조화 방법으로는 힙 파일 구조화, 순차 파일 구조화, 해시 파일 구조화가 있다. 파일 구조 중 다중 테이블 군집 파일 구조는 여러 개의 테이블을 하나의 파일에서 관리하는 특수한 파일 구조이다.

메모리와 디스크는 블럭 단위로 데이터를 주고받는다. 이때 데이터베이스 시스템에서는 블럭의 입출력을 최소화하기 위해 메모리 내에 버퍼라는 공간을 만들며, 버퍼를 효율적으로 관리하기 위해 버퍼 관리자를 사용한다.

버퍼 관리자는 버퍼 공간에 대한 추가적인 공간 요청 시 버퍼 교체 전략을 사용하여 사용된 블록을 디스크로 내보내어 공간을 확보한다.
데이터베이스 시스템에서는 데이터에 대한 빠른 탐색을 지원하기 위해 인덱싱과 해싱을 이용한다.
인덱스는 데이터 파일에 대한 빠른 탐색을 지원하는 부가적인 자료구조이며 인덱스를 생성하는 작업을 인덱싱이라고 한다.
탐색키의 순서로 정렬된 순차 파일에서는 데이터 레코드에 대한 빠른 임의접근이 가능 하도록 순서 인덱스를 사용할 수 있다.
인덱스는 모든 레코드에 대하여 인덱스 엔트리를 구성하는 밀집 인덱스와, 일부 레코드에 해당하는 인덱스 엔트리를 사용하여 인덱스를 구성하는 희소 인덱스, 밀집 인덱스와 희소 인덱스의 개념을 모두 사용한 다단계 인덱스로 구분할 수 있다.
B+–트리 인덱스는 루트에서 단말(leaf) 노드까지 모든 경로의 길이가 같은 높이 균형 트리로 트리에서 단말 노드나 루트 노드가 아닌 중간(internal) 노드는 ⌈n/2⌉과 n 사이의 자식을 갖는 대표적인 인덱스 구조이다.
B+–트리를 활용한 특정 탐색키 탐색은 루트부터 시작해서 단말 노드에 도달할 때까지 비교연산을 하며 이루어진다. 말단 노드에 도착하면 탐색이 종료된다.
새로운 레코드의 삽입과 삭제 시, B+–트리는 재구조화 된다. B+–트리 구조의 생성 조건을 유지시키기 위해 인덱스 엔트리 삽입과 삭제 시 노드의 분할 및 노드의 병합이 이뤄진다.
해싱은 수학적 함수 개념을 사용한 데이터 관리 기법으로 버킷의 개수가 정해진 정적 해싱과 데이터베이스이 크기에 따라 버킷의 개수가 변경되는 동적 해싱으로 구분된다.

해시 함수는 레코드의 탐색키 값과 저장되어야 하는 버킷의 주소를 대응시키는 역할을 수행하며, 레코드가 버킷에 균등하게 배푼되는 해시 함수가 가장 이상적이다.

충돌 발생으로 서로 다른 탐색키가 동일한 버킷에 대응될 수 있으며 이를 동거자라고 한다. 특정 버킷에 많은 충돌이 발생하여 더 이상의 레코드나 인덱스 엔트리가 저장될 수 없을 때 이를 오버플로라 한다.

확장성 해싱은 데이터베이스의 크기에 따라 버킷이 확장되는 동적 해싱 기법의 일종으로 디렉토리와 버킷으로 구성되며 디렉토리의 주소와 버킷의 주소로 구성되는 모조키를 사용한다.

비트맵 인덱스는 다중키를 가진 질의를 보다 효율적으로 처리하기 위해 고안된 인덱스이다. 비트맵은 간단한 비트 배열로 이루어져 있다.

비트맵 인덱스를 사용하여 레코드를 검색 시 주어진 각각의 조건에 해당하는 비트열을 비트 AND 연산을 수행하여 최종적으로 생성되는 비트열로 조건을 만족하는 레코드의 위치를 빠르게 파악할 수 있다.


동시성 제어는 다수의 트랜잭션이 동시에 동일한 데이터에 대해 읽기 연산을 수행하거나 갱신 연산을 수행하려고 할 때, 데이터의 무결성을 유지하면서도 동시에 실행될 수 있는 트랜잭션의 수를 제어하는 기법이다.

대표적인 동시성 제어 기법에는 락 기반 규약, 타임스탬프 순서 규약, 검증 기반 규약(protocol) 등이 있다.

락(lock)이란 한 트랜잭션이 데이터 항목에 접근하는 동안에는 다른 트랜잭션이 그 데이터 항목에 접근하는 것을 제어하는 기법이다.

락킹 기법에는 공유 락(shared lock)과 배타 락(exclusive lock)이 있다. 공유 락은 양립가능하지만 배타 락은 다른 공유, 배타 락과 양립될 수 없다.

2단계 락킹 규약(two–phase locking protocol)은 각 트랜잭션이 락을 요청하는 단계와 언락을 요청하는 두 단계로 구성되어 있다. 트랜잭션은 요청 단계에서부터 시작되며 필요에 따라서 락을 요청할 수 있다. 만약 트랜잭션이 하나의 락을 반납하게 되면 그때부터 트랜잭션은 반납 단계로 되며 더 이상 락 요청을 할 수 없다.

타임스탬프 순서(timestamp ordering) 기법은 트랜잭션 충돌을 위해 직렬 가능한 순서를 정하는 데 가장 많이 사용하는 방법으로, 시스템의 각 트랜잭션마다 고유한 타임스탬프를 부여한다.

타임스탬프가 직렬 가능성을 보장하므로 TS(T1)＜TS(T2)라면 시스템은 T1을 처리한 후 T2를 처리하여 직렬 스케줄과 동등하도록 보장한다.

데이터 회복이란 데이터베이스 운영 도중에 발생하는 예기치 못한 실패나 고장이 발생한 경우 데이터베이스를 실패 및 고장 발생 이전의 일관적인 상태로 되돌리는 작업을 의미한다.

실패 유형에는 논리적 오류나 버퍼 오버플로 등의 요인에 의한 트랜잭션 실패, 하드웨어 고장 등으로 인한 시스템 장애, 디스크 손상으로 인한 디스크 실패가 있다.

디스크와 주기억장치 사이에 블럭 단위로 데이터가 이동되며 디스크상의 블록은 물리적 블럭, 주기억장치상의 블럭은 버퍼 블록이라고 한다. 데이터베이스 응용에서의 데이터 조작은 버퍼 블럭에서 이루어지며, 트랜잭션 완료나 버퍼의 여유 공간이 없을 때 버퍼 블럭이 디스크에 기록된다.

데이터베이스 회복을 위해 가장 많이 사용되는 로그 기반 회복 기법으로 데이터베이스 시스템가 기록한 모든 수정 작업에 대한 기록을 유사 시 데이터베이스를 이전 상태로 복구하는 데에 사용하는 기법이다.

데이터베이스 회복 시 각각의 트랜잭션은 Redo나 Undo된다. 문제없이 진행되어야 했을 트랜잭션의 경우 Redo되며, 완료되지 못한 상황에서 예기치 않게 종료되어 데이터베이스의 일관성을 해칠 위험이 있는 트랜잭션의 경우 Undo된다.

장기간 데이터베이스 운용으로 시스템 장애 발생 시 재실행해야 할 로그의 양이 방대해지기 때문에 체크포인트를 실행하여 최근의 실행된 체크포인트 이후의 로그만으로도 데이터베이스를 회복할 수 있는 방법을 제공한다.

체크포인트를 생성하는 작업은 메모리에 존재하는 모든 로그 레코드를 안정 저장장치로 기록한 후, 수정된 모든 버퍼 블럭을 디스크에 반영한다. 이후 현재 실행 중인 트랜잭션의 리스트를 표시한 를 안정 저장장치에 기록한다.

회복 과정은 오류 발생 기전까지 트랜잭션의 실행 상태에 따라 Redo 또는 Undo 작업으로 분류된다. 정상적으로 완료된 트랜잭션에 대해서는 Redo를 실행하며 불완전 실행된 트랜잭션은 로그를 역순으로 읽어 트랜잭션 실행 전까지 되돌린다.

체크포인트를 사용하는 시스템에 대해서는 마지막 체크포인트를 확인하고 그 이후의 로그에 대해서만 정상적으로 반영되었는지 확인하여 Redo 또는 Undo하면 무결한 데이터베이스를 유지할 수 있다.

SQL
관계대수에 기초하여 RDBMS의 데이터 관리를 위해 설계된 언어
DDL
데이터베이스 객체를 생성, 삭제 또는 구조를 수정하는 명령어의 집합
스키마
한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합
테이블
데이터를 저장하기 위한 2차원 표 형태의 구조

버퍼 블럭
디스크로부터 읽어들여져 주기억장치에 임시적으로 있는 블럭
로그 레코드
데이터베이스가 수행하는 모든 수정 작업을 기록한 데이터
WAL
데이터베이스 수정 전, 로그 레코드를 생성하여 기록하여 변경 기록에 대한 로그를 안정하게 저장하는 기법
체크포인트
회복 작업에 소모되는 비용 감소를 위해 주기적으로 모든 수정 작업을 중단하고 메인 메모리상의 수정된 모든 버퍼블럭을 디스크에 반영시키는 기법