[운영체제]
운영체제는 컴퓨터 시스템의 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 프로그램들의 모습으로 대표적인 시스템 소프트웨어이다.

커널 모드는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드이고, 사용자 모드는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 없는 모드이다.

응용 프로그램은 사용자 모드에서 동작하기에, 하드웨어에 대한 제어가 필요한 경우 시스템 호출을 통해 필요한 서비스를 운영체제에 요청해야 한다.

운영체제의 주요 구성요소에는 프로세스 관리자, 메모리 관리자, 장치관리자, 파일 관리자가 있다.

운영체제의 대표적인 유형으로는 일괄처리 운영체제, 시분할 운영체제, 실시간 운영체제, 분산 운영체제가 있다.

프로세스는 실행 중인 프로그램을 의미하며, CPU, 메모리, 파일, 입출력장치 등 실행에 필요한 자원이 할당된다.

프로세스 제어 블록은 프로세스를 명시해 주는 다양한 내용을 포함하고 있다.

프로세스는 생성, 준비, 실행, 대기, 종료의 다섯 상태 중 하나로 존재하며, CPU의 스케줄링, 입출력 대기 등에 따라 준비, 실행, 대기 등으로 상태가 변화되며 동작한다.

쓰레드는 프로세스에서 실행의 개념만 분리한 것으로 디스패칭의 단위이다.

하나의 프로세스 내에는 하나 이상의 쓰레드가 있을 수 있어, 다중 쓰레드를 생성하여 프로세스 내에서의 다중처리를 할 수 있다.

프로세스의 스케줄링을 위해 상위단계, 하위단계 및 중간단계 스케줄링이 사용된다.

선점 스케줄링 정책은 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식이고, 비선점 스케줄링 정책은 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식이다.

FCFS 스케줄링은 준비 큐에 도착한 순서에 따라 디스패치하는 비선점 방식의 스케줄링 알고리즘이다.

SJF 스케줄링은 준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 비선점 방식의 스케줄링 알고리즘이다.

SRT 스케줄링은 준비 큐에서 기다리는 프로세스 중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 선점 방식의 알고리즘이다.

RR 스케줄링은 프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량에 의해 실행을 제한하는 선점 방식의 스케줄링 알고리즘이다.

HRN 스케줄링은 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치하여 실행하는 비선점 방식의 스케줄링 알고리즘이다.

HRN 스케줄링의 응답비율은 예상실행시간이 짧을수록, 그리고 대기시간이 길수록 커진다.

다단계 피드백 큐 스케줄링은 입출력 위주의 프로세스가 연산 위주의 프로세스보다 우선권을 갖도록 하는 선점 방식의 알고리즘이다.


프로세스가 실행되기 위해서는 수행될 명령이 메모리상에 존재해야 한다.

컴퓨터 시스템의 기억장치는 적은 비용으로 높은 성능을 제공하기 위해 계층적으로 구성된다.

단일 프로그래밍 환경에서의 연속 메모리 할당기법은 관리기법이 단순하지만, 컴퓨터 자원을 효율적으로 사용하는 데 문제가 있다.

다중 프로그래밍을 통해 CPU와 주변장치의 이용률을 높일 수 있다.

고정 분할 방식은 정해진 크기의 분할영역으로 메모리를 활용하는 방식으로, 각 분할영역에서 내부 단편화가 발생할 수 있다.

동적 분할 방식은 각 작업에 필요한 만큼의 메모리를 할당함으로써 내부 단편화를 제거하지만 외부 단편화가 발생할 수 있다.

외부 단편화는 통합과 집약 기법으로 해결 가능하다.

메모리 배치기법은 프로세스를 메모리의 어디에 배치할 것인가 하는 결정과 관련되어 있으며, 최초 적합, 후속 적합, 최적 적합, 최악 적합 기법이 있다.

프로세스가 실행되기 위해서는 수행될 명령이 메모리상에 존재해야 한다.

컴퓨터 시스템의 기억장치는 적은 비용으로 높은 성능을 제공하기 위해 계층적으로 구성된다.

단일 프로그래밍 환경에서의 연속 메모리 할당기법은 관리기법이 단순하지만, 컴퓨터 자원을 효율적으로 사용하는 데 문제가 있다.

다중 프로그래밍을 통해 CPU와 주변장치의 이용률을 높일 수 있다.

고정 분할 방식은 정해진 크기의 분할영역으로 메모리를 활용하는 방식으로, 각 분할영역에서 내부 단편화가 발생할 수 있다.

동적 분할 방식은 각 작업에 필요한 만큼의 메모리를 할당함으로써 내부 단편화를 제거하지만 외부 단편화가 발생할 수 있다.

외부 단편화는 통합과 집약 기법으로 해결 가능하다.

메모리 배치기법은 프로세스를 메모리의 어디에 배치할 것인가 하는 결정과 관련되어 있으며, 최초 적합, 후속 적합, 최적 적합, 최악 적합 기법이 있다.

가상 메모리는 메모리 크기보다 더 큰 기억공간을 사용하는 프로세스를 실행할 수 있다.

프로세스에서 사용되는 가상주소는 동적 주소변환을 통해 메모리의 실주소로 변환된다.

연속적인 가상주소가 실주소 공간에서도 연속적일 필요는 없다.

페이징 기법은 페이지라는 고정된 크기의 블록 단위로 기억장치를 관리하는 기법이다.

세그먼테이션 기법은 모듈화에 따른 논리적 의미에 부합하는 다양한 크기의 세그먼트 단위로 기억장치를 관리하는 기법이다.

요구 페이지 호출기법은 페이지가 필요한 시점에 메모리에 적재하는 방법이다.

예상 페이지 호출기법은 앞으로 사용될 것으로 예상되는 페이지를 미리 메모리에 적재하는 방법이다.

페이지 교체는 메모리가 완전히 사용되고 있을 때, 새로 적재되어야 할 페이지를 위해 어느 페이지가 교체되어야 하는지를 다룬다.

페이지 교체 알고리즘에는 FIFO, LRU, LFU, 2차 기회 페이지 교체 등이 있다.

최적의 페이지 교체방법은 앞으로 가장 오랫동안 사용되지 않을 페이지를 선택하는 방법이지만 현실적으로 불가능하다.

프로세스는 기억장치 내의 정보를 균일하게 액세스하는 것이 아니라 어느 한순간에는 특정 부분을 집중적으로 참조하는 국부성을 보인다.

워킹 세트는 한 프로세스가 최근에 참조한 페이지의 집합이다.

프로세스가 효율적으로 수행되기 위해서는 워킹 세트가 메모리 내에 유지되어야 한다.

PFF 알고리즘의 기본 아이디어는 페이지 부재 빈도가 높으면 페이지 프레임을 해당 프로세스에 더 배정하고 낮으면 회수하는 것이다.

운영체제에서 장치관리자는 시스템의 모든 주변기기를 관리하며 입출력의 균형을 유지한다.

장치는 일반적으로 전용장치, 공유장치 그리고 가상장치의 세 가지 범주로 구분된다.

입출력이 발생하는 경우 이를 처리하는 방법으로 프로그램 방법, 인터럽트 방법, DMA 방법이 있다.

프로그램 방법은 CPU가 입출력장치의 상태를 지속적으로 확인하여 CPU가 원하는 상태가 될 때까지 기다리는 폴링을 이용하는 방법이다.

인터럽트 방법은 어떤 장치가 다른 장치의 작업을 잠시 중단시키고 자신의 상태를 알리는 인터럽트를 이용하는 방법이다.

DMA는 DMA 제어기를 이용하여 CPU를 통하지 않고 메모리에 직접 접근하여 데이터를 전송하는 방법이다.

장치와는 독립적으로 입출력을 관리하는 방법으로 버퍼링과 스풀링이 있다.

버퍼링은 CPU의 데이터 처리속도와 데이터 전송속도의 차이로 인한 문제를 메모리의 일부를 일시적인 데이터 저장장소로 사용하는 버퍼를 이용하여 해결하는 방법으로, 단일 버퍼링, 이중 버퍼링, 순환 버퍼링이 있다.

스풀링은 입출력의 속도를 높이기 위해 입출력 프로세스와 저속 입출력장치 사이의 데이터 전송을 자기 디스크와 같은 고속장치를 통하도록 하는 방법이다.

저장장치는 순차접근 저장장치와 직접접근 저장장치로 나뉜다.

직접접근 저장장치인 자기 디스크의 접근 요구 처리 시간은 탐구시간, 회전지연시간, 전송시간으로 구성된다.

디스크 스케줄링은 디스크 접근 요구를 효율적으로 처리하는 순서를 결정하는 작업으로, 탐구시간을 최소화하는 것이 가장 중요하다.

SSTF 스케줄링 알고리즘은 헤드 위치로부터 탐구시간이 가장 짧은 접근 요구를 먼저 처리하는 방법이다.

SCAN 스케줄링 알고리즘은 양 끝 트랙 사이를 왕복하며 진행방향의 가장 가까운 접근 요구를 먼저 처리하는 방법이다.

C-SCAN 스케줄링 알고리즘은 정해진 한 방향으로만 가장 가까운 접근 요구를 먼저 처리하는 방법으로, 트랙의 끝에 도달하면 반대편 트랙 끝으로 이동한 후 다시 같은 방향으로 진행하는 방법이다.

LOOK과 C-LOOK 스케줄링 알고리즘은 진행방향의 앞쪽에 더 이상 접근 요구가 없으면 바로 방향을 바꾸는 방법이다. 이때 C-LOOK 스케줄링은 반대편 트랙 끝까지 이동하지 않고 가장 먼 접근 요구의 트랙까지만 이동한다.

SLTF 스케줄링 알고리즘은 회전지연시간 최적화를 위한 알고리즘으로, 동일 실린더에서 회전지연시간이 가장 짧은 접근 요구를 먼저 처리하는 방법이다.

파일 관리자는 파일의 생성 · 수정 · 삭제, 파일의 공유 및 액세스 제어, 백업, 정보 보호 등의 기능을 수행한다.

분산 시스템은 네트워크를 통해 약하게 결합된 다양한 성능의 프로세서의 집합이며, 각 프로세서는 자신의 메모리와 클럭을 사용한다.

분산 시스템의 장점은 자원 공유, 성능 향상, 신뢰성 향상, 통신의 편리성이다.

분산 시스템을 관리하기 위한 운영체제가 분산 운영체제이며, 사용자가 원격 자원을 로컬 자원을 사용하는 것처럼 쉽게 사용할 수 있고, 둘 사이의 구별이 없이 투명성을 제공한다.

분산 파일 시스템은 클라이언트가 원격 파일과 로컬 파일을 구별하지 않고 처리할 수 있게 한다.

분산 메모리는 분산 시스템에 속한 컴퓨터들이 메모리를 공유할 수 있게 한다.

원격 메모리는 논리적 메모리를 정의하고 공유하도록 하는 원격 메모리 API를 통해 분산 메모리를 구현한다.

분산 공유 메모리는 가상 메모리 기능을 확장하여, 한 주소공간에 로컬 메모리, 보조기억장치, 원격 메모리를 대응시켜 분산 메모리를 구현한다.

원격 프로시저 호출(RPC)을 통해 한 컴퓨터에서 동작하는 프로그램이 다른 컴퓨터에 있는 프로시저를 호출할 수 있다.
운영체제 보안에서 달성하려는 기본 목표는 기밀성, 가용성, 무결성이다.

정보침해 위협 요소로는 가로채기, 흐름 차단, 변조, 위조 등이 있다.

임의적 접근제어에서는 각 사용자가 자신이 보유하고 있는 자원에 대한 접근권한을 자신의 자율적 판단에 따라 부여하고, 자신이 가진 접근권한을 다른 사용자에게 전달할 수 있다.

강제적 접근제어는 각 객체의 비밀등급, 개별 사용자의 허가등급에 따른 중앙의 규칙에 따라 제어가 이루어진다.

역할 기반 접근제어에서는 사용자는 역할의 멤버가 됨으로써 권한을 배정받는다.

비밀키 암호 시스템은 암호 시스템의 보안이 암호화와 복호화에 사용되는 키를 아는 사람만 정보를 공유할 수 있다는 사실을 이용한다.

공개키 암호 시스템에서는 암호화와 복호화에 사용하는 키가 다르며, 암호화에 사용되는 키는 공개되고 복호화에 사용되는 키는 공개되지 않는다.

참조 모니터는 주체와 객체의 접근권한을 정의한 데이터베이스를 참조하여 보안정책을 수행한다.

벨－라파듈라 모델에서는 기밀성에 중점을 두어, 상위 보안 수준의 정보가 하위 보안수준으로 흐르는 것을 막는다.

비바 모델에서는 무결성에 중점을 두어, 하위 보안 수준의 정보가 상위 보안 수준으로 흐르는 것을 막는다.

프로세스는 실행 중인 프로그램을 의미하며, CPU, 메모리, 파일, 입출력장치 등 실행에 필요한 자원이 할당된다.

프로세스 제어 블록은 프로세스를 명시해 주는 다양한 내용을 포함하고 있다.

프로세스는 생성, 준비, 실행, 대기, 종료의 다섯 상태 중 하나로 존재하며, CPU의 스케줄링, 입출력 대기 등에 따라 준비, 실행, 대기 등으로 상태가 변화되며 동작한다.

쓰레드는 프로세스에서 실행의 개념만 분리한 것으로 디스패칭의 단위이다.

하나의 프로세스 내에는 하나 이상의 쓰레드가 있을 수 있어, 다중 쓰레드를 생성하여 프로세스 내에서의 다중처리를 할 수 있다.





































